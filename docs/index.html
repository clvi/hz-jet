<!DOCTYPE html>
<html>
  <head>
    <title>Stream Processing en mémoire avec HazelCast Jet</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      @page {
          size: 1210px 681px;
          margin: 0;
      }

      @media print {
          .remark-slide-scaler {
              width: 100% !important;
              height: 100% !important;
              transform: scale(1) !important;
              top: 0 !important;
              left: 0 !important;
          }
      }

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      td.logo {
          text-align: center;
          padding-right: 10px;
          width: 150px;
      }

      td.portrait {
          width: 25%;
      }

      img {
          max-width: 100%;
          max-height: 100%;
      }

      div.imgContent {
          max-width: 75%;
          padding-left: 12%;
      }
    </style>
  </head>
  <body>
<textarea id="source">

class: center, middle

# Stream Processing en mémoire avec HazelCast Jet

### Claire Villard

[![Twitter](images/twitter.png)](https://twitter.com/neur0nia) neur0nia

[![GitHub](images/github.png)](https://github.com/leneurone/hz-jet) leneurone/hz-jet

---

# Claire Villard

<div>
<table>
    <tr>
        <td class="logo"><a href="http://v3d.fr"><img src="images/v3d.png"></a></td>
        <td>Développeuse Java depuis 2011 <br/>
            Société V3D</td>
        <td class="portrait" rowspan="4">
            <img alt="Claire Villard" src="images/claire_villard.jpg"/>
        </td>
    </tr>
    <tr>
        <td class="logo"><a href="https://hazelcast.org/"><img src="images/hz.jpg"></a></td>
        <td>Travaille avec HazelCast IMDG depuis 2 ans</td>
    </tr>
    <tr>
        <td class="logo"><a href="http://www.duchess-france.org/"><img src="images/duchess.png"></a></td>
        <td>Membre de Duchess France</td>
    </tr>
    <tr>
        <td class="logo"><a href="http://www.lyonjug.org/"><img src="images/lyonjug.png"></a></td>
        <td>Organisatrice du LyonJUG</td>
    </tr>
</table>
</div>

---

# Qu'est-ce qu'HazelCast IMDG ?

![HazelCast IMDG](images/hz.jpg)

* IMDG = In-Memory Data Grid, Grille de données en mémoire

* Stockage distribué de structures de données (`Map`, `List`, `AtomicLong`, ...)

* Calcul distribué sur ces structures

* Clustering

* Java-based

* Open-source

---

# Qu'est-ce qu'HazelCast Jet ?

![HazelCast Jet](images/jet.png)

* Solution de stream et batch processing basée sur HazelCast IMDG

.imgContent[
![Jet pipeline](images/jet-pipe.png)
]

.footnote[_Sauf mention contraire, les schémas proviennent de https://jet.hazelcast.org/_]
---

# Modélisation

* Utilise les graphes orientés acycliques (DAG, Directed Acyclic Graphs)

.imgContent[
![Distributed DAG](images/distributed-DAG.png)
]

---

# Fonctionnalités

* Nombreuses entrées / sorties

* Faible latence

* Contrôle du débit

* Support des traitements batchs comme des streams finis

* _Sliding windows_

* Facilement extensible

<br />

En v0.5 :

* Tolérance aux crashs de noeuds avec redémarrage des jobs

* Garantie de traitement "au moins 1", "exactement 1" ou "au mieux" des messages

???

Entrées / sorties : streams (IOT, APIs, Kafka Streams, ...), clusters IMDG, databases, HDFS, files, ...

Sliding Windows: Calcul de valeurs aggrégées sur des fenêtres de temps glissantes, avec _watermark_ et Map-Reduce

---

# Roadmap

* Déjà annoncé _production-ready_

* v0.4 sortie le 14 juin 2017

* Release 0.5 : octobre 2017

* 1.0 : prévue début 2018

* APIs instables jusqu'à la v1.0

---

class: center, middle

# En pratique

![DAG](images/dag.png)

---

# DAG

```java
DAG dag = new DAG();

// Création des noeuds de traitement
Vertex source = dag.newVertex("source", Sources.readMap("inputMap"));

Vertex enricher = dag.newVertex("enricher", MetricEnricher::new);

Vertex output = dag.newVertex("output", Sinks.writeMap("outputMap"));
Vertex errorOutput = dag.newVertex("errorOutput", Sinks.writeMap("errorOutputMap"));

// Création des arêtes du graphe entre les noeuds
dag
        .edge(Edge.between(source, enricher))
        .edge(Edge.from(enricher, 0).to(output))
        .edge(Edge.from(enricher, 1).to(errorOutput));

// Démarrage de Jet
JetInstance jet = Jet.newJetInstance();

// Démarrage du Job et attente du résultat
jet.newJob(dag).execute().get();
```

???

On peut choisir l'indice de chaque entrée et sortie des noeuds.

Utile quand un noeud a plusieurs entrées ou sorties.

`between` fix les ID d'entrée et sortie à 0.

---

# Processor

```java
public class MetricEnricher extends AbstractProcessor {

	private IMap<Integer, Customer> customerMap; // IMap des Customers

	@Override
	protected void init(@Nonnull Context context) throws Exception {
        // Utilisation de l'instance HazelCast sous-jacente
		customerMap = context.jetInstance().getHazelcastInstance().getMap("customers");
	}

	@Override
	protected boolean tryProcess0(@Nonnull Object item) throws Exception {
        Metric metric = (Metric) item;

        // On tente de trouver le customer associé à la métrique dans une IMap
        Customer customer = customerMap.get(metric.getCustomerId());

        // On choisit l'arête du graphe à utiliser
        if (customer != null) {
            return tryEmit(0, new EnrichedMetric(metric, customer));
        } else {
            return tryEmit(1, metric);
        }
	}
}
```

???

`tryEmit` renvoie `false` si l'output concerné est plein et ne peut accepter de nouvel item. Le moteur va flusher l'output
concerné, puis soumettre de nouveau l'item en entrée du `Processor`.

Il faudrait ajouter un contrôle avant de caster.

---

# Stream Processing

```java
public class QueuePoller extends AbstractProcessor {
	private IQueue<Metric> inputQueue; // Queue d'entrée

	@Override
	protected void init(@Nonnull Context context) throws Exception {
		inputQueue = context.jetInstance().getHazelcastInstance().getQueue("inputQueue");
	}

    // Utilisation d'un thread dédié obligatoire car poll(int, TimeUnit) est bloquante
	public QueuePoller() { setCooperative(false); }

	@Override
	public boolean complete() {
		try {
			Metric metric = inputQueue.poll(20, TimeUnit.MILLISECONDS);
			if(metric != null) {
				tryEmit(metric);
			}
			return false; // execution infinie tant que complete() retourne false
		} catch (Exception e) {
			return true; // arrêt de l'exécution
		}
    }
}
```

???

Le poller bloque le thread sur la méthode `poll()`, il ne doit pas être coopératif pour ne pas bloquer d'autres threads.

Utilisation de la méthode `poll(long, TimeUnit)` pour pouvoir interrompre l'exécution avec `Future.cancel()`, ou un flag d'arrêt

La métrique est null si le timeout a expiré. Si on ne parvient pas à émettre l'évènement, on attend un peu et on retente.

Si le poller retourne `false` il sera rappelé par le moteur jusqu'à ce qu'il retourne `true` ou que le job soit arrêté.

---

# Performances

* Intel® Core™ i7-5600U CPU @ 2.60GHz × 4
* 16Go RAM
* Fedora 26 64 bits
* JVM Oracle HotSpot 1.8.0_121
* Configuration de Jet par défaut, 2 noeuds locaux

### Batch processing - 1 million de `Metric`

Temps moyen d'exécution du Job : **22s**, soit environ **45 400 items / seconde**

### Stream processing

Injection de `Metric` dans la queue et calcul de la latence totale

Latence moyenne : **2 ms**, latence max. sur 100 000 éléments : **27 ms**

---

# Limitations


* Qualité de la documentation...

* Pas de typage des entrées, sorties, ou arêtes entre noeuds, tout est `Object`.

.center[
![Type casting everywhere](images/type-casting-type-casting-everywhere.jpg)
]

???

Tous les vertex recoivent des `Object`s comme unique type manipulé, le type réel doit donc toujours être contrôlé manuellement

---

class: center, middle

# Merci !

[![GitHub](images/github.png) leneurone/hz-jet](https://github.com/leneurone/hz-jet)


</textarea>
    <script src="js/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
		var slideshow = remark.create({ratio: "16:9"});
    </script>
  </body>
</html>
