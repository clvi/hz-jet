<!DOCTYPE html>
<html>
  <head>
    <title>Stream Processing en mémoire avec HazelCast Jet</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      @page {
          size: 1210px 681px;
          margin: 0;
      }

      @media print {
          .remark-slide-scaler {
              width: 100% !important;
              height: 100% !important;
              transform: scale(1) !important;
              top: 0 !important;
              left: 0 !important;
          }
      }

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      td.logo {
          text-align: center;
          padding-right: 10px;
          width: 150px;
      }

      td.portrait {
          width: 25%;
      }

      img {
          max-width: 100%;
          max-height: 100%;
      }

      div.imgContent {
          max-width: 75%;
          padding-left: 12%;
      }

      .dag-icon {
          float: right;
          width: 320px;
      }
    </style>
  </head>
  <body>
<textarea id="source">

class: center, middle

# Stream Processing en mémoire

# avec HazelCast Jet

### Claire Villard

[![Twitter](images/twitter.png)](https://twitter.com/neur0nia) neur0nia

[![GitHub](images/github.png)](https://github.com/leneurone/hz-jet) leneurone/hz-jet

---

# Claire Villard

<div>
<table>
    <tr>
        <td class="logo"><a href="http://v3d.fr"><img src="images/v3d.png"></a></td>
        <td>Développeuse Java depuis 2011 <br/>
            Société V3D</td>
        <td class="portrait" rowspan="4">
            <img alt="Claire Villard" src="images/claire_villard.jpg"/>
        </td>
    </tr>
    <tr>
        <td class="logo"><a href="http://www.duchess-france.org/"><img src="images/duchess.png"></a></td>
        <td>Membre de Duchess France</td>
    </tr>
    <tr>
        <td class="logo"><a href="http://www.lyonjug.org/"><img src="images/lyonjug.png"></a></td>
        <td>Organisatrice du LyonJUG</td>
    </tr>
</table>
</div>

---

# Qu'est-ce qu'HazelCast IMDG ?

![HazelCast IMDG](images/hz.jpg)

* IMDG = In-Memory Data Grid, Grille de données en mémoire

* Stockage distribué de structures de données (`Map`, `List`, `AtomicLong`, ...)

* Calcul distribué sur ces structures

* Clustering

* Java-based

* Open-source

---

# Qu'est-ce qu'HazelCast Jet ?

![HazelCast Jet](images/jet.png)

* Solution de stream et batch processing basée sur HazelCast IMDG

.imgContent[
![Jet pipeline](images/jet-pipe.png)
]

.footnote[_Sauf mention contraire, les schémas proviennent de https://jet.hazelcast.org/_]
---

# Modélisation

* Utilise les graphes orientés acycliques (DAG, Directed Acyclic Graphs)

.imgContent[
![Distributed DAG](images/distributed-DAG.png)
]

---

# Fonctionnalités

* Nombreuses entrées / sorties

* Faible latence

* Contrôle du débit

* _Sliding windows_

* Facilement extensible

* Tolérance aux crashs de noeuds avec redémarrage des jobs

* Garantie de traitement "au moins 1", "exactement 1" ou "au mieux" des messages

v0.7 :

* Outils de diagnostic et de monitoring

* Scaling dynamique

* Rolling job updates

???

Entrées / sorties : streams (IOT, APIs, Kafka Streams, ...), clusters IMDG, databases, HDFS, files, ...

Sliding Windows: Calcul de valeurs aggrégées sur des fenêtres de temps glissantes, avec _watermark_ et Map-Reduce

---

# Roadmap

* Annoncé _production-ready_ depuis la v0.4 (juin 2017)

* v0.6.1 sortie le 3 mai 2018.

* 1.0 : prévue en 2018

* APIs instables jusqu'à la v1.0

---

class: center, middle

# En pratique

![DAG](images/dag.png)

---

.dag-icon[![DAG](images/dag.png)]

# DAG

```java
DAG dag = new DAG();

// Création des noeuds de traitement
Vertex source = dag.newVertex("source", Sources.readMap("inputMap"));

Vertex enricher = dag.newVertex("enricher", MetricEnricher::new);

Vertex output = dag.newVertex("output", Sinks.writeMap("outputMap"));
Vertex errorOutput = dag.newVertex("errorOutput", Sinks.writeMap("errorOutputMap"));
```

```java
// Création des arêtes du graphe entre les noeuds
dag
        .edge(Edge.between(source, enricher))
        .edge(Edge.from(enricher, 0).to(output))
        .edge(Edge.from(enricher, 1).to(errorOutput));
```

```java
// Démarrage de Jet
JetInstance jet = Jet.newJetInstance();

// Démarrage du Job et attente du résultat
jet.newJob(dag).execute().get();
```

???

On peut choisir l'indice de chaque entrée et sortie des noeuds.

Utile quand un noeud a plusieurs entrées ou sorties.

`between` fix les ID d'entrée et sortie à 0.

---

.dag-icon[![DAG](images/dag.png)]

# Processor

```java
public class MetricEnricher extends AbstractProcessor {

	// ...

	@Override
	protected boolean tryProcess0(@Nonnull Object item) throws Exception {

        Metric metric = (Metric) item;

        // ... on fait des traitements

        // Arête 0 ou 1 selon que le traitement s'est terminé en succès ou non
        int index = (error ? 1 : 0);

        // si la sortie est surchargée, tryEmit renverra false
        boolean emissionSucceeded = tryEmit(index, metric);

        // le process sera retenté si on retourne false
        return emissionSucceeded;
	}
}
```

???

`tryEmit` renvoie `false` si l'output concerné est plein et ne peut accepter de nouvel item. Le moteur va flusher l'output
concerné, puis soumettre de nouveau l'item en entrée du `Processor`.

Il faudrait ajouter un contrôle avant de caster.

---

.dag-icon[![DAG](images/dag-stream.png)]

# Stream Processing

```java
public class QueuePoller extends AbstractProcessor {

    // ...

	@Override
	public boolean complete() {

        Metric metric = inputQueue.poll(20, TimeUnit.MILLISECONDS);

        if(metric != null) {
            // on envoie le message dans le pipeline de traitement
            tryEmit(metric);
        }

        return false; // execution infinie tant que complete() retourne false
    }
}
```

???

Le poller bloque le thread sur la méthode `poll()`, il ne doit pas être coopératif pour ne pas bloquer d'autres threads.

Utilisation de la méthode `poll(long, TimeUnit)` pour pouvoir interrompre l'exécution avec `Future.cancel()`, ou un flag d'arrêt

La métrique est null si le timeout a expiré. Si on ne parvient pas à émettre l'évènement, on attend un peu et on retente.

Si le poller retourne `false` il sera rappelé par le moteur jusqu'à ce qu'il retourne `true` ou que le job soit arrêté.

---

# Performances

* Intel® Core™ i7-5600U CPU @ 2.60GHz × 4
* 16Go RAM
* Fedora 26 64 bits
* JVM Oracle HotSpot 1.8.0_121
* Configuration de Jet par défaut, 2 noeuds locaux

.dag-icon[![DAG](images/dag.png)]

### Batch processing - 1 million de `Metric`

Temps moyen d'exécution du Job : **22s**, soit environ **45 400 items / seconde**

.dag-icon[![DAG](images/dag-stream.png)]

### Stream processing

Injection de `Metric` dans la queue et calcul de la latence totale

Latence moyenne : **2 ms**, latence max. sur 100 000 éléments : **27 ms**

---

# Limitations


* Qualité de la documentation...

* Pas de typage des entrées, sorties, ou arêtes entre noeuds, tout est `Object`.

.center[
![Type casting everywhere](images/type-casting-type-casting-everywhere.jpg)
]

???

Tous les vertex recoivent des `Object`s comme unique type manipulé, le type réel doit donc toujours être contrôlé manuellement

---

class: center, middle

# Merci !

[![GitHub](images/github.png) leneurone/hz-jet](https://github.com/leneurone/hz-jet)


</textarea>
    <script src="js/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
		var slideshow = remark.create({ratio: "16:9"});
    </script>
  </body>
</html>
